---
title: API Blog Post
name: Minna
date: today
---

This blog post aims to walk you through the different types of API usage (in R).

## Terminology 
- **API** = Application Programming interface. (machine-to-machine) 
- An API receives inbound requests and sends outbound responses. the client makes a HTTP request to the API server, the API defines and then waits for the server's response. 
- **API Endpoint** the connecting point between API client and API server & handles the transfer of data between client & server.
- REST **HTTP methods**: 
    - GET
    - POST
    - PUT
    - DELETE


<!-- 
matt comments
- Anhand der erklären lernen eine Swagger Doku zu verstehen. Am besten anhand von einem Economics API Beispiel. 
- API Wrapper ist auch wichtig zu erklären, auch die Motivation so etwas zu machen -->


## DIY - how do the different terminologies look in code

### 1. Create your own API

using {plumber} you can create your own Web API in R. 

Let's say, we want to share a certain time series with the world, so we create an API where users can `GET` the kof barometer in full, or starting at specific times, or ending at specific times. 

```{r, echo=FALSE, results=FALSE, warnings=FALSE, messages=FALSE}
# install the latest version
# devtools::install_github("KOF-ch/kofdata")
library(kofdata)
# list_available_collections()
data <- get_time_series("kofbarometer", show_progress = TRUE)
str(data$kofbarometer)
```

For this, we first need to create a function `partition_ts` which takes the parameters the API users pass to the endpoint, i.e. a start and end date, and then partitions the time series according to those params. 

```r
#* @param start date at which ts should start - can be years only, or c(year, month)
#* @param end date at which ts should end - can be years only, or c(year, month)

partition_ts <- function(ts, start = NULL, end = NULL) {
  if (inherits(ts, "ts")) {
    # setting start and end date if unset
    if (is.null(end)) {
      end <- time(ts)[length(ts)]
    }
    if (is.null(start)) {
      start <- time(ts)[1]
    }
    # filter ts based on start & end dates
    ts <- window(ts, start = start, end = end)
  } else {
    warning("Input is not a ts object")
    return(NULL)
  }
  return(ts)
}
# let's pretend the data comes from my own source
partition_ts(data$kofbarometer, end = c(2010, 2))
```

Now, we use the above created function to create the function for users to get the data. We set the endpoint to `/data` so users can get the data from this location

```r

library(plumber)
#* return entire time series data
#* @get /data
function() {
  # list(msg = paste0("does this work?"))
  partition_ts(data$kofbarometer)
}
```
Next we create another function where users can `GET` data at the `/filtered_data` endpoint, where they can also specify the `start` and `end` dates, to not get the entire time series.

```r
#* return data w/ start and end dates.
#* @param start the start year to filter by
#* @param end the end year to filter by
#* @get /filtered_data

function(start = NULL, end = NULL) {
  if (!is.null(start)) {
    start <- as.numeric(start)
  }
  if (!is.null(end)) {
    end <- as.numeric(end)
  }

  partition_ts(
    data$kofbarometer,
    start = start,
    end = end
  )
}
```

Finally, the last function can be used to get a png of the time series plotted, under the endpoint `/plotting`. 

```r
#* return the Plot the entire ts
#* @serializer png
#* @get /plotting
function() {
  plot(data$kofbarometer)
}

```

::: {.callout-tip}

To actually create your API, you can run the code snippets above in a file called plumber.R in the RStudio IDE, or run the following in your R console: 

```r
# to set the port 
 pr("plumber.R") %>%
   pr_run(port=8000)

plumb(file='plumber.R')$run()
```

:::

When running (=plumbing) this file, it looks like this:

![Swagger Documentation of our API](img/endpoints.png)

Let's try out the endpoint `/filtered_data`

![Setting Params for the Request](img/set_params.png)

When we execute this, what do we get?

![Time Series Data](img/get_requests.png)

IMPORTANT IS: Swagger is just a documentation aid, it helps visualise the endpoints, and run requests.
In real life, a request & response can look like this:

![Real Call](img/real_call.png)

### 2. Create your own Wrapper

using the {httr2 package} - Let's say we know people only want to get the kofbarometer until 2019, since from 2020 onwards, the data is different, so we create an API wrapper, around the previously written /filtered_data endpoint to get only the data until 2019


To use the API we just created ourselves, we need to ensure our custom API is being hosted -> but to do that we need to pay, either through digitalocean, or POSIT. 

So, as an alternative, i will just use the kof API.

```{r}
# install.packages("httr")
library(httr)
library(jsonlite)


kofbaro_until_2020 <- function() {
  base_url <- "https://datenservice.kof.ethz.ch/api/v1/public/ts"
  query <- list(
    keys = ts_key,
    df = "Y-m-d"
  )

  # if (!is.null(start)) query$start <- start
  # if (!is.null(end)) query$end <- end

  response <- GET(base_url, query = query)

  data <- fromJSON(content(response, as = "text", encoding = "UTF-8"))

  return(data)
}

```


### 3. With an existing API Wrapper 

using {kofdata}

```{r}
# install the latest version
# devtools::install_github("KOF-ch/kofdata")
library(kofdata)
data <- get_time_series("kofbarometer", show_progress = TRUE)
plot(data$kofbarometer)
```

The End.